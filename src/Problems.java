

import java.io.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Random;
import java.util.Scanner;

/**
 * @author yiwen zhong
 *
 */

public class Problems {
	public static Problems problem = null;
	public static String fileName = null;
    public static Random rand = new Random();
    
	//to open the file generated by myself
	private Problems(String fileName) throws FileNotFoundException,IOException {
		Problems.fileName = fileName;
       	readFile(fileName);
 	}
	
	/**
	 * The problem to be solved is:
     * Max  sum{j=1,...,n} p(j)x(j)
     * s.t. sum{j=1,...,n} w(i,j)x(j) <= b(i)       i=1,...,m
                     x(j)=0 or 1
  
 	 * The format of the data file is:
     *    number of items (n), number of dimensions (m = 1 always), optimal solution value (zero if unavailable)
     *    the value of items p(j); j=1,...,n
     *    for each dimension i (i=1,...,m): the weights of items w(i,j); j=1,...,n
     *    the capacity of dimension b(i); i=1,...,m	
	 * 
	 * 
	 * @param fileName
	 * @throws FileNotFoundException
	 * @throws IOException
	 */
	private void readFile(String fileName) throws FileNotFoundException,IOException{
		FileReader data;
		Scanner scan;

		data = new FileReader(fileName);
		scan = new Scanner(data);
		itemNumber = scan.nextInt();
		scan.nextInt();
		bestValue = scan.nextDouble();
		if (bestValue == 0) {
			bestValue = Integer.MAX_VALUE;
		}
		//to read values of item
		values = new double[itemNumber];
		for (int i = 0; i < itemNumber; i++) {
			values[i] = scan.nextDouble();
		}
		
		//to read the weight of item for each dimension
		weights = new double[itemNumber];
		for (int j = 0; j < itemNumber; j++) {
			weights[j] = scan.nextDouble();
		}
	
		
		//to read the capacity
		capacity = scan.nextDouble();

		scan.close();
		data.close();
		

		//sort items
		List<Item> list = new ArrayList<>();
		for (int index = 0; index < itemNumber; index++) {
			list.add(new Item(index, values[index], weights[index]));
		}
		Collections.sort(list);
		Collections.reverse(list);
		densityOrder = new int[itemNumber];
		densityList = new ArrayList<>();
		for (int i = 0; i < list.size(); i++) {
			densityOrder[i] = list.get(i).getID();
			densityList.add(densityOrder[i]);
		}
		
		Collections.sort(list, Comparator.comparing( u -> u.getValue()));
		Collections.reverse(list);
		valueOrder = new int[itemNumber];
		valueList = new ArrayList<>();
		for (int i = 0; i < list.size(); i++) {
			valueOrder[i] = list.get(i).getID();
			valueList.add(valueOrder[i]);
		}
		
		Collections.sort(list, Comparator.comparing( u -> u.getWeight()));
//		Collections.reverse(list);
		weightOrder = new int[itemNumber];
		weightList = new ArrayList<>();
		for (int i = 0; i < list.size(); i++) {
			weightOrder[i] = list.get(i).getID();
			weightList.add(weightOrder[i]);
		}
	}

	public static Problems getProblem() {
		if (problem == null) {
			try {
				problem = new Problems(fileName);
			} catch (FileNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		return problem;
	}

	public static void setFileName(String fileName) {
		Problems.fileName = fileName;
		try {
			problem = new Problems(fileName);
		} catch (Exception ex) {
			ex.printStackTrace();
		}
	}


	public String toString() {
		StringBuffer out=new StringBuffer();

		out.append(itemNumber + "\t" + bestValue +  "\n");
		for (int i = 0; i < values.length; i++) {
			out.append(values[i]+"\t");
		}
		out.append("\n");
	
		for (int i = 0; i < weights.length; i++) {
			out.append(weights[i]+"\t");
		}
		out.append("\n");
		
		out.append(capacity+"\n");
			
		return out.toString();
	}
	
	
	public int getItemNumber() { return itemNumber;}
	public double getCapacity() { return capacity;}
	public double getItemValue(int item) { return values[item];}
	public double getItemWeight(int item) { return weights[item];}
	public double getBestValue() { return bestValue;}
	public int[] getDensityOrder() { return densityOrder;}
	public int[] getValueOrder() { return valueOrder;}
	public int[] getWeightOrder() { return weightOrder;}
	public List<Integer> getDensityList() { return densityList;}
	public List<Integer> getValueList() { return valueList;}
	public List<Integer> getWeightList() { return weightList;}

    private int itemNumber;
    
	private double[] values = null; //values of items
	private double capacity = 0; //capacities of dimensions of knapsack
	private double[] weights = null; //weight of item for each dimension of knapsack
	private double bestValue; //the best known solution
	
	private int[] densityOrder;
	private int[] valueOrder;
	private int[] weightOrder;
	private List<Integer> densityList;
	private List<Integer> valueList;
	private List<Integer> weightList;

	
	public static void main(String[] args) throws IOException {
		//readAndSaveFiles();
		createInstance(10, 0, 1000);
		createInstance(10, 1, 1000);
		createInstance(10, 2, 1000);
	}
	
	
	public static void createInstance(int instanceNumber, int type, int itemNumber) {
		for (int inst = 0; inst < instanceNumber; inst++) {
			int[] values = new int[itemNumber];
			int[] weights = new int[itemNumber];
			int capacity = 0;
			String valuesStr = "";
			String weightsStr = "";
			for (int i = 0; i < itemNumber; i++) {
				if (type == 0) { //uncorrelated
					weights[i] = 10 + Problems.rand.nextInt(101-10);
					values[i] = 10 + Problems.rand.nextInt(101-10);
				} else if ( type == 1) { //weaklycorrelated
					weights[i] = 10 + Problems.rand.nextInt(101-10);
					values[i] = weights[i] - 10 + Problems.rand.nextInt(21);
				} else {
					weights[i] = 10 + Problems.rand.nextInt(101-10);
					values[i] = weights[i] + 10;
				}
				capacity += weights[i];
				valuesStr += values[i] + "\t";
				weightsStr += weights[i] + "\t";
				if ((i+1) % 10 == 0) {
					valuesStr += "\r\n";
					weightsStr += "\r\n";
				}
			}
			capacity = capacity * 3 / 4;
			
			//save data
			String dirPath = (new File("")).getAbsolutePath() + "/../paras/";
			dirPath += (type==0)?"uncorrelated/":((type==1)?"weaklycorrelated/":"stronglycorrelated/");
			File dir = new File(dirPath);
			if (!dir.exists()) {
				dir.mkdir();
			}
			String fileName = dirPath;
			if (inst < 10) {
				fileName += "0" + inst + "-" + type +  ".txt";
			} else {
				fileName += inst + "-" + type + ".txt";
			}
			try {
				PrintWriter printWriter = new PrintWriter(new FileWriter(fileName));
				printWriter.println(itemNumber + " 1  0");
				printWriter.println();
				printWriter.println(valuesStr);
				printWriter.println();
				printWriter.println(weightsStr);
				printWriter.println();
				printWriter.println(capacity);
				printWriter.close();
			} catch (Exception ex) {
				ex.printStackTrace();
			}
		}
	}
	
	public static void readAndSaveFiles() throws IOException {
		String filePath = (new File("")).getAbsolutePath() + "/../cbFiles/";
		File[] files = (new File(filePath)).listFiles();
		for (File file : files) {
			//mkdir
			String dirName = file.getName().replaceAll(".txt", "");
			String dirPath = (new File("")).getAbsolutePath() + "/../" + dirName + "/";
			File dir = new File(dirPath);
			if (!dir.exists()) {
				dir.mkdir();
			}
			FileReader data;
			Scanner scan;
			data = new FileReader(file);
			scan = new Scanner(data);
			
			int instanceNumber = scan.nextInt();
			for (int inst = 1; inst <= instanceNumber; inst++) {
				int itemNumber = scan.nextInt();
				int dimensionNumber = scan.nextInt();
				int bestValue = scan.nextInt();
				//to read values of item
				int[] values = new int[itemNumber];
				for (int i = 0; i < itemNumber; i++) {
					values[i] = scan.nextInt();
				}
				
				//to read the weight of item for each dimension
				int[][] constraints = new int[dimensionNumber][itemNumber];
				double[][] weights = new double[itemNumber][dimensionNumber];
				for (int i = 0; i < dimensionNumber; i++) {
					for (int j = 0; j < itemNumber; j++) {
						constraints[i][j] = scan.nextInt();
						weights[j][i] = constraints[i][j];
					}
				}
				
				//to read the capacities of dimension
				int[] capacities = new int[dimensionNumber];
				for (int i = 0; i < dimensionNumber; i++) {
					capacities[i] = scan.nextInt();
				}	
				
				StringBuffer out= new StringBuffer();

				out.append(itemNumber + "\t" + dimensionNumber + "\t" + bestValue +  "\n");
				out.append("\r\n");
				for (int i = 0; i < values.length; i++) {
					out.append(values[i]+"\t");
				}
				out.append("\r\n");
				
			
				for (int i=0; i<constraints.length; i++) {
					for (int j=0; j<constraints[i].length; j++) {
						out.append(constraints[i][j]+"\t");
					}
					out.append("\r\n");
				}

				for (int i = 0; i < capacities.length; i++) {
					out.append(capacities[i]+"\t");
				}
				out.append("\r\n");
				
				String fileName = dirPath;
				if (inst < 10) {
					fileName += "0" + inst + "-" + dirName +  ".txt";
				} else {
					fileName += inst + "-" + dirName + ".txt";
				}
				try {
					PrintWriter printWriter = new PrintWriter(new FileWriter(fileName));
					printWriter.println(out);
					printWriter.close();
				} catch (Exception ex) {
					ex.printStackTrace();
				}
			}
			scan.close();
			data.close();
		}
	}
}

class Item implements Comparable<Item>{
	private int id;
	private double value;
	private double density;
	private double weight;
	
	public Item(int id, double value, double weight) {
		this.id = id;
		this.value = value;
		this.weight = weight;
		density = value / weight;
	}
	
	
	
	public int getID() { return id; }
	public double getValue() { return value;}
	public double getWeight() { return weight;}
	public double getDensity() { return density; }



	@Override
	public int compareTo(Item o) {
		if (this.density > o.density) {
			return 1;
		} else if (this.density == o.density) {
			return 0;
		} else {
			return -1;
		}
	}
}

